import { Callout, Tabs, Tab } from "nextra/components"
import { TutorialSchema } from "../../components/TutorialSchema"

# Generate data

<Callout emoji="ðŸ¥">
  This is a preview feature. We would love your [feedback](https://app.snaplet.dev/chat)!
</Callout>

## The need for generated data

Generated data, or seed data, is a useful tool in software development, providing an initial set of data for your database.

Here's why it's beneficial:

- **Development:** Provides a consistent dataset for developers.
- **Testing:** Ensures predictability when verifying features.
- **Demonstration:** Showcases your software's abilities with example content.
- **Default Data:** Adds necessary built-ins, like country lists.
- **Onboarding:** Gives new users a filled-out starting point.
- **Performance:** Helps simulate heavy usage scenarios.
- **Guides:** Common reference in tutorials.

While generated data might be the unsung hero of early development, it can get a bit needy as software evolves. But don't sweat it! Our mission is to save you from the never-ending saga of maintaining those seed scripts. Who has time for that, right?

## Introducing the Snaplet Data Client

The key to effortless generated data is a tool that deeply understands your database's schema. By introspecting your database, we are able to create a fully-typed client dedicated to data generation.

Right now, the Snaplet Data Client is tied to our configuration file, but we intend to generate a standalone version that you will be able to use anywhere!

Let's see how it works.

## Generating data with `snaplet generate`

### Prerequisites

- The [Snaplet CLI](/getting-started/installation)

### Defining your first plan

To illustrate, let's consider a sample database schema for a blogging application:

<Tabs items={["diagram", "sql"]}>
<Tab>
<TutorialSchema className="nx-mx-auto nx-my-4" />
</Tab>
<Tab>
```sql
CREATE TABLE public."User" (
  id uuid NOT NULL PRIMARY KEY,
  username text NOT NULL,
  email text NOT NULL
);
CREATE TABLE public."Post" (
  id uuid NOT NULL PRIMARY KEY,
  title text NOT NULL,
  content text NOT NULL,
  "createdBy" uuid NOT NULL REFERENCES public."User"(id)
);
CREATE TABLE public."Comment" (
  id uuid NOT NULL PRIMARY KEY,
  content text NOT NULL,
  "userId" uuid NOT NULL REFERENCES public."User"(id),
  "postId" uuid NOT NULL REFERENCES public."Post"(id),
  "writtenAt" timestamptz NOT NULL DEFAULT now()
);
```
</Tab>
</Tabs>

Based on this schema, we'll create a data generation plan that fulfills the following criteria:

- Generate a post titled "Hello World!"
- Specify the author's email to end with "acme.org."
- Add three comments to the post.

Now let's translate these requirements into a plan with the Snaplet Data Client.

<CH.Scrollycoding className="generate-tutorial-configuration-file">

First, we need to define the `generate` key in our [`snaplet.config.ts`](/reference/configuration) file.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {

  },
});
```

---

The `generate` key accepts a `plan` function in which an instance of the Snaplet Data Client is injected as `snaplet`.

```ts snaplet.config.ts focus=7:9
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {

    },
  },
});
```

---

The Snaplet Data Client exposes all your models as functions. These functions return a plan. You always start from a root model, here we start from the `Post` model.

```ts snaplet.config.ts focus=8:10
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({

      });
    },
  },
});
```

---

You use the `data` key to define the values of your model.

```ts snaplet.config.ts focus=9:11
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
        },
      });
    },
  },
});
```

---

You can also define the values of your model's relations. Here we define the author of the post represented by the `User` model.

```ts snaplet.config.ts focus=11:18
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
        },
      });
    },
  },
});
```

---

Finally, we also define the comments of the post represented by the `Comment` model. As we need more than one comment, we use the `count` key.

```ts snaplet.config.ts focus=19:21
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
          },
        },
      });
    },
  },
});
```

---

Sounds like a plan!

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
          },
        },
      });
    },
  },
});
```

</CH.Scrollycoding>

> We drew inspiration from [Prisma](https://www.prisma.io/) in designing our client. If you're familiar with Prisma, using the Snaplet Data Client should feel familiar.

### Executing the plan

At this point, you're ready to run your first `snaplet generate`!

Let's see what statements are generated by using the `--sql` option.

Run this command in your terminal:

```bash >_&nbsp;terminal
snaplet generate --sql
```

You should see the following output:

<CH.Slideshow className="generate-tutorial-sql-output">

Let's break it down.

```sql >_&nbsp;terminal
INSERT INTO public."User" (email,id,username) VALUES
('Craig.Bednar82365@acme.org', '24058b0d-21ec-54b8-a3fa-b0ad8034f10f', 'site-glance56860'),
('Humberto.Bruen34274@meternephew.org', '241ed1d9-c36c-50d4-b783-e12ce5187076', 'Alexis-Gleason29168'),
('Mattie.Braun26688@plodantechamber.com', '8c84c800-1b34-5843-b34b-73d3239f0c5b', 'blissful-fountain21234'),
('Dannie_Osinski74665@brownmidline.name', '0e041e68-00c0-53db-b0f8-e28be8a009e0', 'visualise-service97805');

INSERT INTO public."Post" (title,content,"createdBy",id) VALUES
('Hello World!', 'Ramo ramukin rae racea rakesoma, me vayota yume vi keyo munavima.', '24058b0d-21ec-54b8-a3fa-b0ad8034f10f', '1a294726-1661-5d42-aaf6-cdb66e6c6eaf');

INSERT INTO public."Comment" (content,id,"postId","userId","writtenAt") VALUES
('Ma ceasova yuviketa shira chiyomu.', '13fdf8d2-2199-5dfd-81d0-c8dd3ce3b8a6', '1a294726-1661-5d42-aaf6-cdb66e6c6eaf', '241ed1d9-c36c-50d4-b783-e12ce5187076', DEFAULT),
('Mukinra kahyceako kiva kai me hameso rae.', '71a504eb-a859-5217-9e27-e15975ac69c6', '1a294726-1661-5d42-aaf6-cdb66e6c6eaf', '8c84c800-1b34-5843-b34b-73d3239f0c5b', DEFAULT),
('Ma nacea va memumi ta, mami viyua yoma shimusona viyo metake.', '8e826b31-f774-57f3-8ef2-183bddb35f3e', '1a294726-1661-5d42-aaf6-cdb66e6c6eaf', '0e041e68-00c0-53db-b0f8-e28be8a009e0', DEFAULT);
```

---

This is the post, titled "Hello World!" as intended!

```sql >_&nbsp;terminal focus=8

```

---

This is the author of the post, notice the "acme.org" in the email.

```sql >_&nbsp;terminal focus=2

```

---

And here are the 3 comments.

```sql >_&nbsp;terminal focus=11:13

```

---

These 3 users were automatically generated to satisfy the 3 comments. You didn't need to define them, the Snaplet Data Client did it for you, because it knows your schema relationships it can fulfill them automatically.

```sql >_&nbsp;terminal focus=3:5

```

</CH.Slideshow>

It's now time to persist these data in your target database.

In order to do that, run this command in your terminal:

```bash >_&nbsp;terminal
snaplet generate
```

All done, it's time to code against your generated data!

### Connecting to existing data

Let's take a moment to understand what happened under the hood.

You used the **snaplet data client** to define a **plan**. We then executed this plan to generate **SQL statements**. Finally, we executed these SQL statements to **persist the data in your database**.

Internally, a plan persist the generated data in an in-memory object called a **store**. This is actually the store that is turned into SQL statements.

If we take our previous plan, its `store` would look like this:

```ts
const store = {
  User: [User, User, User, User],
  Post: [Post],
  Comment: [Comment, Comment, Comment],
}
```

This store is very useful when you want to `connect` your models together, reusing existing data instead of generating new one. Let's see how to do that.

#### Using `connect`

In addition to the `data` key, you can use the `connect` key to connect your models together.

<CH.Scrollycoding className="generate-tutorial-configuration-file">

Let's start from our previous plan.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
          },
        },
      });
    },
  },
});
```

---

We specify that the author of each comment will be provided from an external source rather than being generated using the `connect` key.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
            // focus(1:6)
            data: {
              User: {
                connect: () => {}
              }
            }
          },
        },
      });
    },
  },
});
```

---

We can use the injected `store` to provide the `User` model we want to connect to. In this case the only generated `User` in the plan will be the author of the post.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
            data: {
              User: {
                connect: ({ store }) => {
                  // focus
                  return store.User[0];
                }
              }
            }
          },
        },
      });
    },
  },
});
```

</CH.Scrollycoding>

##### `graph`

If your plan is complex, it can be quite challenging to find the right model to connect to. That's why we also provide the `graph` variable to the `connect` function.

The `graph` contains all the data that was generated as part of the plan, arranged to follow the shape of your plan.

And here is how you can use it:

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
            data: {
              User: {
                // focus(1:4)
                // we alias the graph to posts to make it more readable
                connect: ({ graph: posts }) => {
                  return posts[0].User;
                }
              }
            }
          },
        },
      });
    },
  },
});
```

Here is what the `graph` looks like for this plan:

```ts
// as we started with snaplet.Post, the graph is an array of Post
const graph = [
  {
    User: User,
    Comment: [
      Comment,
      Comment,
      Comment
    ],
  },
];
```

##### `branch`

Now let's complexify our plan a bit:

- We want to generate 3 posts.
- The author of each post should also be the author of the post's comments.

It seems challenging to find the right User to connect to using `store` or `graph`. That's why we also provide the `branch` variable to the `connect` function.

The `branch` is a particular iteration of the `graph` that was generated. It matches the path to the `connect` function in which it is injected.

Let's take a look at the `branch` for our previous plan, adapted to our new requirements:

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet }) {
      return snaplet.Post({
        // focus
        count: 3,
        data: {
          title: 'Hello World!',
          User: {
            data: {
              email: ({ seed }) =>
                copycat.email(seed, {
                  domain: 'acme.org'
                }),
            },
          },
          Comment: {
            count: 3,
            data: {
              User: {
                // focus(1:4)
                // we alias the branch to post to make it more readable
                connect: ({ branch: post }) => {
                  return post.User;
                }
              }
            }
          },
        },
      });
    },
  },
});
```

Generating 3 posts will result in 3 branches, each containing a post, its author and its comments.

In our above example, the `connect` function will receive the branch corresponding to its iteration. So the first `connect` function will receive the first branch, the second `connect` function will receive the second branch, and so on.

Here is what the `branch` looks like for this particular `connect` function:

```ts
// as we started with snaplet.Post, the branch is a Post model
const branch = {
  User: User,
  Comment: Comment,
};
```

### Manipulating stores

We saw that a **plan** is persisting the generated data in a **store**, and the store will be turned into **SQL statements**.

Sometimes, it's easier to break down your plan into multiple plans, and then merge them together. That's why we provide the `pipe` and `merge` functions.

#### Using `pipe`

The `pipe` operator allows you to chain multiple plans together, injecting the `store` of the previous plan into the next plan.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet, pipe }) {
      return pipe(
        snaplet.User({
          count: 3
        }),
        snaplet.Post({
          data: {
            User: {
              connect({ store }) {
                // this is the first User generated by the previous plan
                return store.User[0];
              }
            }
          }
        })
      );
    },
  },
});
```

##### `autoConnect`

We provide a special option that you can activate in the options of a plan, called `autoConnect`.

When `true`, the plan will automatically connect models relationships to fulfill to the store if possible. The corresponding model will be picked randomly (but deterministically, we're using `copycat.oneOf` method under the hood).

In the following example, the `Post` model will be connected to one of the 3 `User` in the store.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet, pipe }) {
      return pipe(
        snaplet.User({
          count: 3
        }),
        // mark
        snaplet.Post({}, { autoConnect: true })
      );
    },
  },
});
```

#### Using `merge`

The `merge` operator allows you to merge multiple plans together, without injecting the `store` of the previous plan into the next plan. All stores stay independent and are merged together once all the plans are generated.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    plan({ snaplet, merge }) {
      return merge(
        snaplet.User({
          count: 3
        }),
        snaplet.Post({}),
        snaplet.Comment({
          count: 2
        })
      );
    },
  },
});
```